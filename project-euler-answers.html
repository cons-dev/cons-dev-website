<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-W51-5 00:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Project Euler Answers</title>
<meta name="author" content="Inanna" />
<meta name="description" content="Answers to project euler problems." />
<meta name="generator" content="Org Mode" />
<link href="site.css" rel="stylesheet" type="text/css" /><link href="images/website-icon.png" rel="icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div><a href="index.html"><img id="site-logo" src="images/website-logo.png" /></a></div>
</div>
<div id="content" class="content">
<h1 class="title">Project Euler Answers</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org85b1f1d">Summary</a></li>
<li><a href="#org07ac575">1: Multiples of 3 or 5</a>
<ul>
<li><a href="#org4a2963b">Brute Force Answer</a></li>
<li><a href="#org8ff9945">Optimized Answer</a></li>
</ul>
</li>
<li><a href="#orgacdc6f5">2: Even Fibonacci Numbers</a></li>
<li><a href="#org32fe25f">3: Largest Prime Factor</a>
<ul>
<li><a href="#org750c6b0">Finding Prime Numbers</a>
<ul>
<li><a href="#org6d9cffd">Checking for Divisibility</a></li>
<li><a href="#org2b12bc1">Sieve of Eratosthenes</a></li>
<li><a href="#org41c1152">A More Ugly Approach</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1dc646a">774: Conjunctive Sequences</a>
<ul>
<li><a href="#org24a173f">Brute Force Approach</a></li>
<li><a href="#org0dc8a0d">O(n)</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org85b1f1d" class="outline-2">
<h2 id="org85b1f1d">Summary</h2>
<div class="outline-text-2" id="text-org85b1f1d">
<p>
My answers to various project Euler problems. I occasionally will be doing these because they are fun and pretty entertaining.
</p>
</div>
</div>


<div id="outline-container-org07ac575" class="outline-2">
<h2 id="org07ac575">1: Multiples of 3 or 5</h2>
<div class="outline-text-2" id="text-org07ac575">
</div>

<div id="outline-container-org4a2963b" class="outline-3">
<h3 id="org4a2963b">Brute Force Answer</h3>
<div class="outline-text-3" id="text-org4a2963b">
<p>
Here I use the simple brute force answer, which is to generate a list to 1000 and then get the multiples of three and five in that list using the modulus operator. It's pretty short but I probably can code golf-it and optimize it quite a bit.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">letfn</span> <span style="color: #bbb;">[</span><span style="color: #494949;">(</span>divisible? <span style="color: #bbb;">[</span>n div<span style="color: #bbb;">]</span> <span style="color: #bbb;">(</span>zero? <span style="color: #494949;">(</span>mod n div<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> <span style="color: #494949;">(</span>range 1000<span style="color: #494949;">)</span>
       <span style="color: #494949;">(</span>filter #<span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">or</span> <span style="color: #494949;">(</span>divisible? <span style="font-style: italic;">%</span> 3<span style="color: #494949;">)</span> <span style="color: #494949;">(</span>divisible? <span style="font-style: italic;">%</span> 5<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
       <span style="color: #494949;">(</span>apply +<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ff9945" class="outline-3">
<h3 id="org8ff9945">Optimized Answer</h3>
<div class="outline-text-3" id="text-org8ff9945">
<p>
So instead of that approach there's a much faster one using recursion.<label class="sidenote-number" for="1"><sup>1</sup></label><input checked="checked" id="1" style="display:none" type="checkbox" /><span class="sidenote"><span class="sidenote-number"> 1</span> the n-ary function syntax for Clojure is really nice here, allowing me to use default arguments.</span>
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">letfn</span> <span style="color: #bbb;">[</span><span style="color: #494949;">(</span>multiples-to
          <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>n mul<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>multiples-to n mul <span style="color: #bbb;">[]</span> 1<span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
          <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>n mul l i<span style="color: #494949;">]</span>
           <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">let</span> <span style="color: #bbb;">[</span>multiple <span style="color: #494949;">(</span>* i mul<span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
             <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">if</span> <span style="color: #494949;">(</span>&gt; multiple n<span style="color: #494949;">)</span> l <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">recur</span> n mul <span style="color: #bbb;">(</span>conj l multiple<span style="color: #bbb;">)</span> <span style="color: #bbb;">(</span>inc i<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> <span style="color: #494949;">(</span>concat <span style="color: #bbb;">(</span>multiples-to 1000 3<span style="color: #bbb;">)</span>
               <span style="color: #bbb;">(</span>multiples-to 1000 5<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
       distinct
       <span style="color: #494949;">(</span>apply +<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
This answer unfortunately only really shows improvements in efficiency when the multiples are around 100 or 300, rather than 3 and 5. In fact, it is actually considerably less efficient than the first "brute-force" answer in the 3-5 case.
</p>
</div>
</div>
</div>

<div id="outline-container-orgacdc6f5" class="outline-2">
<h2 id="orgacdc6f5">2: Even Fibonacci Numbers</h2>
<div class="outline-text-2" id="text-orgacdc6f5">
<p>
This just gets even fib numbers. There's not much to optimize here because the process is both fairly simple and (as far as I can tell) cannot be changed.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">letfn</span> <span style="color: #bbb;">[</span><span style="color: #494949;">(</span>fib
          <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>max-num<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>fib max-num <span style="color: #bbb;">[</span>1 2<span style="color: #bbb;">]</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
          <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>max-num lst<span style="color: #494949;">]</span>
           <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">let</span> <span style="color: #bbb;">[</span>next <span style="color: #494949;">(</span>apply + <span style="color: #bbb;">(</span>take 2 lst<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
             <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">if</span> <span style="color: #494949;">(</span>&gt; next max-num<span style="color: #494949;">)</span>
               lst
               <span style="color: #494949;">(</span>fib max-num <span style="color: #bbb;">(</span>cons next  lst<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
  
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> <span style="color: #494949;">(</span>fib 4000000<span style="color: #494949;">)</span>
       <span style="color: #494949;">(</span>filter even?<span style="color: #494949;">)</span>
       <span style="color: #494949;">(</span>apply +<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org32fe25f" class="outline-2">
<h2 id="org32fe25f">3: Largest Prime Factor</h2>
<div class="outline-text-2" id="text-org32fe25f">
<p>
The goal is to find the largest prime factor of a number. To start we will first begin by creating a function that finds a number of primes up to the target value divided by 2. This is because the target value will, ultimately, be at most \(n \times 2\).
</p>
</div>

<div id="outline-container-org750c6b0" class="outline-3">
<h3 id="org750c6b0">Finding Prime Numbers</h3>
<div class="outline-text-3" id="text-org750c6b0">
<p>
To start out we find a list of prime numbers. A neat feature of prime numbers is that to test a number for primality you both only need to test for the division of a number by other prime numbers up to the square root of the value, for the largest number will be at most the square root.
</p>
</div>

<div id="outline-container-org6d9cffd" class="outline-4">
<h4 id="org6d9cffd">Checking for Divisibility</h4>
<div class="outline-text-4" id="text-org6d9cffd">
<p>
To start off, and to make our code more clear, we define a small predicate called <code>divisible?</code> which checks if a number is divisible by some other number. While it doesn't really shorten the code all that much, it adds clarity to the code
</p>
<div class="org-src-container">
<pre class="src src-clojure" id="orge7849f1"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">divisible?</span> <span style="color: #bbb;">[</span>num div<span style="color: #bbb;">]</span> <span style="color: #bbb;">(</span>zero? <span style="color: #494949;">(</span>mod num div<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2b12bc1" class="outline-4">
<h4 id="org2b12bc1">Sieve of Eratosthenes</h4>
<div class="outline-text-4" id="text-org2b12bc1">
<p>
The most elegant solution would be the sieve of Eratosthenes. The logic behind it is fairly simple:
</p>
<ol class="org-ol">
<li>all natural numbers are either primes or a composite of a number of primes</li>
<li>a number is prime if no prime divisor less than itself exists</li>
<li>therefore, if one creates a list from \(2...n\) and takes the head of the list and filter out all divisors, add the head to a second list, and continue until the list is emptied the second list should contain the primes from \(2...n\)</li>
</ol>

<p>
As you can see, it follows that the list generated will be entirely comprised of prime numbers.
</p>

<p>
To solve this we can implement a lazy sieve of Eratosthenes. Lazy in that the resulting sequence will be infinite.
</p>
<div class="org-src-container">
<pre class="src src-clojure" id="org29811e7"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">seive</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[]</span> <span style="color: #494949;">(</span>seive <span style="color: #bbb;">(</span>drop 2 <span style="color: #494949;">(</span>range<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>l<span style="color: #494949;">]</span>
   <span style="color: #494949;">(</span>lazy-seq
    <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">let</span> <span style="color: #494949;">[</span><span style="color: #bbb;">[</span>x &amp; xs<span style="color: #bbb;">]</span> l<span style="color: #494949;">]</span>
      <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">if</span> <span style="color: #bbb;">(</span>empty? xs<span style="color: #bbb;">)</span>
        <span style="color: #bbb;">[</span>x<span style="color: #bbb;">]</span>
        <span style="color: #bbb;">(</span>cons x <span style="color: #494949;">(</span>seive <span style="color: #bbb;">(</span>filter #<span style="color: #494949;">(</span>not <span style="color: #bbb;">(</span>divisible? <span style="font-style: italic;">%</span> x<span style="color: #bbb;">)</span><span style="color: #494949;">)</span> xs<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>

<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">def</span> <span style="font-style: italic;">primes</span> <span style="color: #bbb;">(</span>seive<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Unfortunately this does not work for what we want. It is very beautiful, and I wish it did work, but because of the specific features of TCO in Clojure <label class="sidenote-number" for="2"><sup>2</sup></label><input checked="checked" id="2" style="display:none" type="checkbox" /><span class="sidenote"><span class="sidenote-number"> 2</span> Even with the <code>recur</code> special form.</span> it doesn't actually produce TCO code, and, because it is recursive, will end up causing a stack overflow.
</p>

<p>
However, because of the lazy list semantics you can take a nearly infinite series of primes from it, assuming you only increase your requested list size by one each time you take from it. This is interesting, though unfortunately not something I can really use.
</p>
</div>
</div>

<div id="outline-container-org41c1152" class="outline-4">
<h4 id="org41c1152">A More Ugly Approach</h4>
<div class="outline-text-4" id="text-org41c1152">
<p>
So in order to solve this we can rewrite the is-prime function to, rather than generating a list from 0 to \(n\) and then filtering it, simply loop until a value at the range of the prime number is found. This ensures that the space complexity of it is \(O(\log(n))\) rather than \(O(n)\), though does not change the time complexity.
</p>

<p>
First we define an <a href="https://clojure.org/reference/atoms">atom</a> to <a href="https://en.wikipedia.org/wiki/Memoization">memoize</a> our primes called <code>found-primes</code>, and initialize it with the first prime number, 2.
</p>
<div class="org-src-container">
<pre class="src src-clojure" id="org7eed331"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">def</span> ^<span style="color: #E53935;">:private</span> <span style="font-style: italic;">found-primes</span>
  <span style="color: #a4a4a4; font-style: italic;">"A map of all primes that have been found thus far by the system"</span>
  <span style="color: #bbb;">(</span>atom #<span style="color: #494949;">{</span>2<span style="color: #494949;">}</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">def</span> ^<span style="color: #E53935;">:private</span> <span style="font-style: italic;">max-prime</span> <span style="color: #bbb;">(</span>atom 2<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Next we define an <code>is-prime?</code> predicate which will test if a value is prime by iterating over the list of primes that are less than the square root of the new value. This is basically the same as the sieve of Eratosthenes applied to a single element. Below is the function itself, don't worry, we will break it down.
</p>

<div class="org-src-container">
<pre class="src src-clojure" id="org96c6eca"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">is-prime?</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>n<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>is-prime? n <span style="color: #E53935;">false</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>n contiguous?<span style="color: #494949;">]</span>
   <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">let</span> <span style="color: #bbb;">[</span>max-div <span style="color: #494949;">(</span>int <span style="color: #bbb;">(</span>inc <span style="color: #494949;">(</span><span style="color: #E53935;">Math</span>/sqrt n<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
     <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">letfn</span> <span style="color: #494949;">[</span><span style="color: #bbb;">(</span>div? <span style="color: #494949;">[</span>n<span style="color: #494949;">]</span>
               <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> @found-primes
                    <span style="color: #bbb;">(</span>take-while #<span style="color: #494949;">(</span>&gt; max-div <span style="font-style: italic;">%</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
                    <span style="color: #bbb;">(</span>some #<span style="color: #494949;">(</span>divisible? n <span style="font-style: italic;">%</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
                    not<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">]</span>
       <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">cond</span>
         <span style="color: #bbb;">(</span>contains? @found-primes n<span style="color: #bbb;">)</span>
         <span style="color: #E53935;">true</span>

         <span style="color: #bbb;">(</span>&gt; @max-prime n<span style="color: #bbb;">)</span>
         <span style="color: #E53935;">false</span>

         <span style="color: #bbb;">(</span>&lt; @max-prime max-div<span style="color: #bbb;">)</span>
         <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">doall</span> <span style="color: #bbb;">(</span>map #<span style="color: #494949;">(</span>is-prime? <span style="font-style: italic;">%</span> <span style="color: #E53935;">true</span><span style="color: #494949;">)</span> <span style="color: #494949;">(</span>range @max-prime max-div<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
             <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">if</span> <span style="color: #bbb;">(</span>div? n<span style="color: #bbb;">)</span>
               <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #494949;">(</span>swap! found-primes conj n<span style="color: #494949;">)</span>
                   <span style="color: #E53935;">true</span><span style="color: #bbb;">)</span>
               <span style="color: #E53935;">false</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>

         <span style="color: #bbb;">(</span>div? n<span style="color: #bbb;">)</span>
         <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">if</span> contiguous?
               <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #494949;">(</span>swap! found-primes conj n<span style="color: #494949;">)</span>
                   <span style="color: #494949;">(</span>reset! max-prime n<span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
               <span style="color: #bbb;">(</span>swap! found-primes conj n<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
             <span style="color: #E53935;">true</span><span style="color: #bbb;">)</span>

         <span style="color: #E53935;">:else</span> <span style="color: #E53935;">false</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>


<p>
There are, however, a number of fun tricks being used to speed up the computation. First we generate the maximum divisor using this little bit of code. This isn't really the maximum size of the prime divisor, but rather the maximum size of the minimum element of the pair of divisors produced.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span>int <span style="color: #bbb;">(</span>inc <span style="color: #494949;">(</span><span style="color: #E53935;">Math</span>/sqrt n<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>


<p>
Next we have the conditional. First it checks if the number is in the list of found primes, and if it is then it simply returns <code>true</code>. This means that it has \(O(1)\) runtime should the prime be found already. <label class="sidenote-number" for="3"><sup>3</sup></label><input checked="checked" id="3" style="display:none" type="checkbox" /><span class="sidenote"><span class="sidenote-number"> 3</span> Though in Clojure, since sets are trees, it has more \(O(log(n))\) runtime.</span>
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span>contains? @found-primes n<span style="color: #494949;">)</span>
      <span style="color: #E53935;">true</span>
</pre>
</div>

<p>
But, if it is both not in the list of found primes <i>and</i> is less than the largest prime, it must be the case that it is not a prime, and therefore it returns false. 
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span>&gt; @max-prime n<span style="color: #494949;">)</span>
<span style="color: #E53935;">false</span>
</pre>
</div>

<p>
Following this we check the case that the <code>max-prime</code> is smaller than <code>max-div</code>. In this case we check the primality of every prime from the last largest prime to the <code>max-div</code>. This places each prime number in the set of found primes and ensures that it can run and check if the number is prime. Following that we check that <code>n</code> is prime.
</p>

<p>
We do add it to the list of primes, but we don't set the <code>max-prime</code>, even though it far exceeds it. This is because the value <code>max-prime</code> represents the maximum prime for which all primes lower than it are known. In this case not all primes lower than it are known.
</p>

<p>
Unfortunately it is not possible to, for any \(n\) know that it is the next prime without testing the range between n and the previous prime. Therefore, for now, this part of it is the only way to check if previous elements are prime.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span>&lt; @max-prime max-div<span style="color: #494949;">)</span>
<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">doall</span> <span style="color: #494949;">(</span>map #<span style="color: #bbb;">(</span>is-prime? <span style="font-style: italic;">%</span> <span style="color: #E53935;">true</span><span style="color: #bbb;">)</span> <span style="color: #bbb;">(</span>range @max-prime max-div<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
    <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">if</span> <span style="color: #494949;">(</span>div? n<span style="color: #494949;">)</span>
      <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #bbb;">(</span>swap! found-primes conj n<span style="color: #bbb;">)</span>
          <span style="color: #E53935;">true</span><span style="color: #494949;">)</span>
      <span style="color: #E53935;">false</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Now we check if a number is or is not in fact prime, and in this case we do set the prime in the event it is contiguous because the number is the next number in the set of found primes.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span>div? n<span style="color: #494949;">)</span>
<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">if</span> contiguous?
      <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">do</span> <span style="color: #bbb;">(</span>swap! found-primes conj n<span style="color: #bbb;">)</span>
          <span style="color: #bbb;">(</span>reset! max-prime n<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
      <span style="color: #494949;">(</span>swap! found-primes conj n<span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
    <span style="color: #E53935;">true</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Once we have this function, we can then begin to look into generating the primes to some value. Like before we want to ensure that we can use as many numbers form our prime list as possible, therefore we implement a simple function that will first attempt to return all the values from our <code>found-primes</code> list. should they not exist, it will then use the side effects of the <code>is-prime?</code> function to generate it.
</p>

<div class="org-src-container">
<pre class="src src-clojure">&lt;&lt;divisible?&gt;&gt;

<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">prime-range</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>end<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>prime-range 2 end<span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>start end<span style="color: #494949;">]</span>

   <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">if</span> <span style="color: #bbb;">(</span>@max-prime<span style="color: #bbb;">)</span>
     <span style="color: #bbb;">(</span>drop-while<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
   
   <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> <span style="color: #bbb;">(</span>range <span style="color: #494949;">(</span>max start 2<span style="color: #494949;">)</span> end<span style="color: #bbb;">)</span>
        <span style="color: #bbb;">(</span>filter is-prime?<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>

<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">prime-factors</span> <span style="color: #bbb;">[</span>x<span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> <span style="color: #494949;">(</span>prime-range <span style="color: #bbb;">(</span>inc <span style="color: #494949;">(</span><span style="color: #E53935;">Math</span>/sqrt x<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
       <span style="color: #494949;">(</span>filter #<span style="color: #bbb;">(</span>divisible? x <span style="font-style: italic;">%</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>


<span style="color: #494949;">(</span>last <span style="color: #bbb;">(</span>prime-factors 600851475143<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org1dc646a" class="outline-2">
<h2 id="org1dc646a">774: Conjunctive Sequences</h2>
<div class="outline-text-2" id="text-org1dc646a">
<p>
Conjunctive sequences are defined as the finite integer sequences for which the bitwise and operation on any adjacent pair within the sequence will not yield 0 as an answer. The function that we are asked to implement \(C(n, b)\) returns the number of sequences of length \(n\) all of whose terms are less than \(b\).
</p>
</div>

<div id="outline-container-org24a173f" class="outline-3">
<h3 id="org24a173f">Brute Force Approach</h3>
<div class="outline-text-3" id="text-org24a173f">
<p>
First we can start by defining a simple brute force approach. This will take the length of the sequences \(n\) and the maximum value of any element of the sequences \(b\) and generate every possible sequence within the list. Then it will check if they are conjunctive, convert those true/false answers to numbers
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">num-conj-seq</span> <span style="color: #bbb;">[</span>n b<span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">letfn</span> <span style="color: #494949;">[</span><span style="color: #bbb;">(</span>conjunctive? <span style="color: #494949;">[</span><span style="color: #bbb;">[</span>x y &amp; xs<span style="color: #bbb;">]</span><span style="color: #494949;">]</span>
            <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">let</span> <span style="color: #bbb;">[</span>seq-n <span style="color: #494949;">(</span>not <span style="color: #bbb;">(</span>zero? <span style="color: #494949;">(</span>bit-and x y<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">]</span>
              <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">cond</span> <span style="color: #494949;">(</span>empty? xs<span style="color: #494949;">)</span> <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">if</span> seq-n <span style="color: #E53935;">true</span> <span style="color: #E53935;">false</span><span style="color: #494949;">)</span>
                    <span style="color: #494949;">(</span>not seq-n<span style="color: #494949;">)</span> <span style="color: #E53935;">false</span>
                    <span style="color: #E53935;">:else</span>       <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">recur</span> <span style="color: #bbb;">(</span>cons y xs<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">]</span>
    <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> <span style="color: #bbb;">(</span>range n <span style="color: #494949;">(</span>inc b<span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
         <span style="color: #bbb;">(</span>map #<span style="color: #494949;">(</span>range <span style="color: #bbb;">(</span>- <span style="font-style: italic;">%</span> n<span style="color: #bbb;">)</span> <span style="font-style: italic;">%</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
         <span style="color: #bbb;">(</span>map conjunctive?<span style="color: #bbb;">)</span>
         <span style="color: #bbb;">(</span>filter true?<span style="color: #bbb;">)</span>
         count<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0dc8a0d" class="outline-3">
<h3 id="org0dc8a0d">O(n)</h3>
<div class="outline-text-3" id="text-org0dc8a0d">
<p>
However, the brute force approach, when given that string, will have a time complexity of \(O(n \times b)\), which is obviously something we <i>don't</i> want for our system, and is also the reason why I didn't just generate the answer using the brute force approach.
</p>

<p>
Instead we should think about what we want. So first we must imagine what the rules of the sequence are. Bitwise operations take two values \(a\) and \(b\) and convert them into effectively arrays of 1's and 0's. Therefore, for a sequence to be conjunctive we can conclude that at least one of the one-valued indexes in the lowest or highest value of the sequence must be one as well. That is to say that, given the bounds on this sequence, we can conclude it is not conjunctive out of the bat.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Lower</td>
<td class="org-right">010001</td>
</tr>

<tr>
<td class="org-left">Higher</td>
<td class="org-right">101110</td>
</tr>
</tbody>
</table>

<p>
Now in essence we must determine that for each index within the lower value if it will at any point between the lower value and the higher value become zero. So to solve this we can imagine each bit as something that is set to zero every \(x\%n\) numbers. To illustrate let's come up with a list of numbers
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Binary</th>
<th scope="col" class="org-right">Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0001</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0010</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0011</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0100</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0101</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">0110</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">0111</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">1000</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">1001</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-right">1010</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
As we can see the LSB, \(b\) is 0 for each value that satisfies \(n%2 < 0\) where \(n\) is the number. We can also see that the second bit is 0 for each value that satisfies the equation \(n%4 < 2\)
</p>

<p>
From this we can create a generalized equation to find if a value becomes zero:
</p>

<p>
\(\displaystyle n\%2^{p+1} < 2^p\)
</p>

<p>
or, in Clojure:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bit-idx-0?</span> <span style="color: #bbb;">[</span>p n<span style="color: #bbb;">]</span> <span style="color: #bbb;">(</span>&lt; <span style="color: #494949;">(</span>mod n <span style="color: #bbb;">(</span><span style="color: #E53935;">Math</span>/pow 2 <span style="color: #494949;">(</span>inc p<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span> <span style="color: #494949;">(</span><span style="color: #E53935;">Math</span>/pow 2 p<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Where \(p\) is the index from the LSB and \(n\) is the number.
</p>

<p>
To determine if a sequence is conjunctive we want to determine if  \(p\) becomes zero from \(\{n, n+1...n+b\}\). To start out with solving this we first find where the next point at which it will be zero will occur, that is to say the next value at which \(n\%2^{p}\) will be zero. To do this we can simply take:
\(\displaystyle \left\lfloor \frac{n}{2^{p}} \right\rfloor + 2^{p}\)
</p>

<p>
From here \(p\) becomes zero from \(\{n, n+1...n+b\}\) if the result of the equation is less than \(n+b\), and therefore the value of \(p\) is zero for the sequence. Or:
</p>

<p>
\(\displaystyle n+b >  \left\lfloor \frac{n}{2^{p}} \right\rfloor + 2^{p}\)
</p>

<p>
From here we can see that the solution is to check if any 1 valued bit of \(n\) satisfies the above. If it does then the value is conjunctive.
</p>

<p>
Therefore we can apply this predicate to all for all values \(n\) in the set \(\{0, 1..b-n\}\) and then find the number of true values produced by this. This reduces our search time to \(O(n)\) which is fairly respectable.
</p>
</div>
</div>
</div>
<!-- Footnotes --><!-- 
<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">the n-ary function syntax for Clojure is really nice here, allowing me to use default arguments.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Even with the <code>recur</code> special form.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Though in Clojure, since sets are trees, it has more \(O(log(n))\) runtime.</p></div></div>

 --></div>
<div id="postamble" class="status">
<p class="date">Last Modified: 2021-W51-4 12:36</p><p class="creator">Generated Using: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.6)</p><p class="license">Except where otherwise noted content on <a href="https://cons.dev">cons.dev</a> is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
</div>
</body>
</html>
