:PROPERTIES:
:ID:       827f33ef-5fdf-41eb-970b-dbef134112b7
:END:
#+TITLE: Dodgy Game
#+SUBTITLE: Download this game and run it as root! I promise nothing bad will happen.
#+DESCRIPTION: A simple game.
#+PROPERTY: header-args :noweb no-export
#+FILETAGS: :website:public:game:source_code:

* Introduction
A while back I wrote a basic little game in [[http://www.quil.info/][quil]] where you dodge the various oncoming objects. I wrote it as a simple way to learn to make games. But now that I am better at programming (and love rule engines) I have decided to rewrite the game and also add it to my website. You can mess around with it [[file:~/Memex/cons-site/public/dodgy/index.html][here]].

* Setup
** Defining the Project
Because this is a separate project I have to define the lein build stuff here.
#+BEGIN_SRC clojure :tangle ./dodgy/project.clj
(defproject dodgy "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url  "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [org.clojure/clojurescript "1.10.520"]
                 [com.cerner/clara-rules "0.21.1"]
                 [quil "3.1.0"]]

  :plugins [[lein-cljsbuild "1.1.7"]
            [lein-figwheel "0.5.19"]]
  :hooks [leiningen.cljsbuild]

  :clean-targets ^{:protect false} ["resources/public/js"]
  :cljsbuild
  {:builds [; development build with figwheel hot swap
            {:id           "development"
             :source-paths ["src"]
             :figwheel     true
             :compiler
             {:main       "dodgy.core"
              :output-to  "resources/public/js/main.js"
              :output-dir "resources/public/js/development"
              :asset-path "js/development"}}
                                        ; minified and bundled build for deployment
            {:id           "optimized"
             :source-paths ["src"]
             :compiler
             {:main          "dodgy.core"
              :output-to     "resources/public/js/main.js"
              :output-dir    "resources/public/js/optimized"
              :asset-path    "js/optimized"
              :optimizations :advanced}}]})
#+END_SRC


** The Build Script
To build the thing I have a little script that is run every time that this file is exported. It first tangles the entire buffer and then it calls.

#+BEGIN_SRC sh
cp -r ./dodgy/resources/public/* ../public/dodgy/
#+END_SRC

#+RESULTS:

** HTML
#+BEGIN_SRC html :tangle ./dodgy/resources/public/index.html
<!DOCTYPE html>
<html>
  <head>
    <title>cubes</title>
  </head>
  <body style="background-color:#a4a4a4;font-family: 'Jura';">
    <div id="dodgy" style="margin: auto;"></div>
    <script src="js/main.js"></script>
    <script>dodgy.core.run_sketch()</script>
  </body>
</html>
#+END_SRC

* Initial Setup
This initially sets up the game. Again, WIP and being rewritten to be more modular.
#+BEGIN_SRC clojure :tangle ./dodgy/src/dodgy/core.cljs
(ns dodgy.core
  (:require [quil.core :as q :include-macros true]
            [quil.middleware :as m]
            [dodgy.render :as render]
            [dodgy.stages :as stages]))

(def ^:private default-player-position
  {:x -20
   :y 20})

(defn setup []
  (q/frame-rate 30)
  {:text          (str "Controls:\n"
                       "The arrow keys control acceleration.\n"
                       "\n"
                       "Rules:\n"
                       "Hitting purple squares ends the game.\n"
                       "Hitting orange squares increments the score counter.\n"
                       "The longer you play the more frequently orange squares spawn.\n"
                       "Squares move at a function of your speed.\n"
                       "\n"
                       "Good luck!\n"
                       "Press any key to continue...")
   :speed         0
   :distance      0
   :player-color  {:x -20
                   :y 20}
   :enemies       []
   :point-squares []
   :time          0
   :score-color   0
   :max-score     0
   :stage         "title"})


;; this function is called in index.html
(defn ^:export run-sketch []
  (let [width  (- (.-innerWidth js/window) 15)
        height (- (.-innerHeight js/window) 20)]
    (q/defsketch dodgy
      :host "dodgy"
      :size [width height]
      ;; setup function called only once, during sketch initialization.
      :setup setup
      ;; update-state is called on each iteration before draw-state.
      :update stages/update-stage-state
      :draw render/render-state
      :middleware [m/fun-mode])))

#+END_SRC


* Game Engine
This is the basic set of functions that run the game engine. They are currently utility functions but will soon be rules.
#+BEGIN_SRC clojure :tangle  ./dodgy/src/dodgy/engine.cljs
(ns dodgy.engine
  "The engine behind the game. It provides utility functions that are used in the
  state update function. I will be  rewriting these as I reactor the code-base of
  the game."
  (:require [quil.core :as q :include-macros true]))

(defn entity-bounds
  "Returns the rectangle representing the bounds of a size 20 square entity."
  [{:keys [:x :y]}]
  [(- x 20) x (- y 20) y])

(defn intersect?
  "Whether the two given rectangles intersect."
  [[axmin axmax aymin aymax] [bxmin bxmax bymin bymax]]
  (and (>= aymax bymin) (<= aymin bymax) (>= axmax bxmin) (<= axmin bxmax)))

(defn player-alive?
  "Returns whether the player-color has stayed clear of the walls and enemies."
  [player-color min-x max-x min-y max-y enemies]
  (and (intersect? [(:x player-color) (:x player-color) (:y player-color) (:y player-color)] [min-x max-x min-y max-y])
       (not-any? (fn [enemy-color] (intersect? (entity-bounds player-color) (entity-bounds enemy-color))) enemies)))

(defn gc-entities
  "Filters out out of bounds entities."
  [max-y entities]
  (filter (fn [ent]
            (let [ent-y (:y ent)]
              (<= ent-y (+ max-y 30))))
          entities))

(defn update-point-square-pos
  "Updates the position of the point dodgy."
  [player-color max-y point-squares speed]
  (->> point-squares
       (filter (fn [point] (not (intersect? (entity-bounds player-color) (entity-bounds point)))))
       (gc-entities max-y)
       (map (fn [point]
              {:x (:x point)
               :y (+ (:y point) (* (:speed-mul point) speed))
               :speed-mul (:speed-mul point)}))))

(defn update-enemy-pos
  "Updates the positions of each enemy-color."
  [max-y enemies speed]
  (->> enemies
       (gc-entities max-y)
       (map (fn [enemy-color]
              {:x (:x enemy-color)
               :y (+ (:y enemy-color) (* (:speed-mul enemy-color) speed))
               :speed-mul (:speed-mul enemy-color)}))))

(defn gen-enemies
  "Generates enemies and updates their positions."
  [min-x max-x min-y max-y time speed enemies]
  (let [spawn-freq (/ 60 (* (inc (/ (+ 10 time) 500))
                            (/ (q/width) 700)))]
    (if (and (= 0 (mod time (max 1 (int spawn-freq))))
             (< 0.4 (max speed (- speed)))
             (< 100 time))
      (concat (update-enemy-pos max-y enemies speed)
              (map (fn []
                     {:x (q/random min-x max-x)
                      :y (- min-y 20)
                      :speed-mul (q/random 1.5 0.5)})
                   (repeat (max 1 (int (/ 1 spawn-freq))) 1)))
      (update-enemy-pos max-y enemies speed))))

(defn update-score
  "Updates the score-color of the player-color."
  [player-color score-color point-squares]
  (reduce (fn [acc point]
            (if (intersect? (entity-bounds player-color) (entity-bounds point))
              (inc acc)
              (+ acc 0))) score-color point-squares))

(defn gen-point-squares
  "This calculates when the enemies should be spawned in the game.
  the spawn frequency calculation computes the frequency with which
  enemies will spawn."
  [player-color min-x max-x min-y max-y point-squares speed time]
  (if (and (= 0 (mod time (int (/ 128 (/ (q/width) 700)))))
           (< 0.4 (max speed (- speed))))
    (conj (update-point-square-pos player-color max-y point-squares speed)
          {:x (q/random min-x max-x)
           :y (- min-y 20)
           :speed-mul (q/random 1.5 0.5)})
    (update-point-square-pos player-color max-y point-squares speed)))

(defn update-player
  "This updates the player-color state."
  [player-speed-x player-speed-y player-x player-y]
   {:x (+ player-x player-speed-x)
    :y (+ player-y player-speed-y)
    :speed-x player-speed-x
    :speed-y player-speed-y})
#+END_SRC


* Input

#+BEGIN_SRC clojure :tangle  ./dodgy/src/dodgy/input.cljs
(ns dodgy.input "This obtains user input.")

(def keystates (atom {}))
(def keys-by-code {37 :left 38 :up 39 :right 40 :down})

(defn update-keystate! [state code]
  (when-let [k (get keys-by-code code)]
    (swap! keystates assoc k state)))

(.addEventListener js/window "keydown" (fn [e] (update-keystate! :pressed (. e -keyCode))))
(.addEventListener js/window "keyup" (fn [e] (update-keystate! nil (. e -keyCode))))

(defn get-x-accel []
  (+ (if (= (get @keystates :left) :pressed) -0.5 0)
     (if (= (get @keystates :right) :pressed) 0.5 0)))

(defn get-y-accel []
  (+ (if (= (get @keystates :up) :pressed) -0.5 0)
     (if (= (get @keystates :down) :pressed) 0.5 0)))

#+END_SRC

* Rendering
This renders the various entities.
#+BEGIN_SRC clojure :tangle  ./dodgy/src/dodgy/render.cljs
(ns dodgy.render
  "The rendering function. It renders the data based upon the stage of the game."
  (:require [quil.core :as q  :include-macros true]))


(def enemy-color [0xf5 0x7f 0x17])
(def score-color [0x7c 0x1f 0xa3])
(def player-color [0xe5 0x39 0x35])
(def bg [0xff 0xff 0xff])

(defn render-square [[r g b] thickness size {x :x y :y}]
  (let [inner (- size (* thickness 2))]
    (q/fill r g b)
    (q/rect x y size size)))


(defn render-entities [{spawned? :spawned? player :player-color enemies :enemies point-squares :point-squares}]
  (q/text (str spawned?) 100 100)
  (q/with-translation [(/ (q/width) 2)
                       (/ (q/height) 2)]
    ;; Draw enemies and points
    (dorun (map (partial render-square score-color 2.5 20) point-squares))
    (dorun (map (partial render-square enemy-color 2.5 20) enemies))
    ;; Draw the player-color
    (render-square player-color 2.5 20 player)))

(defn render-state [state]
  (q/background 0xff 0xff 0xff)
  (q/stroke 0xff 0xff 0xff)
  (render-entities state)
  (q/fill player-color)
  (q/text (str (:text state)
               (if (= (int (mod (q/seconds) 2)) 0)
                 "█"
                 "")) 10 20))

#+END_SRC

* Game Stages
The game stages are large update functions that wrangle the massive amount of state represented by the game state function into something usable.
#+BEGIN_SRC clojure :tangle ./dodgy/src/dodgy/stages.cljs
(ns dodgy.stages
  "A series of different functions that serves to manage the state of the game,
  splitting it into a number of different \"stages\" that are synchronized with
  the rendering function. Each stage manages the state of the code and changes
  between the different stages. Future games will not use a stage system and
  instead endeavor for a more simple mono-stage ECS system."
  (:require [dodgy.input :as io]
            [dodgy.engine :as engine]
            [quil.core :as q :include-macros true]))
<<title-stage>>
<<game-stage>>
<<score-stage>>
<<update-stage-state>>
#+END_SRC

** title-stage
This simply waits for user input from the initial state of the game.
#+NAME: title-stage
#+BEGIN_SRC clojure
(defn title-stage
  "The initial stage of the game where the title is displayed."
  [state]
  (merge
   state
   (when (q/key-pressed?)
     {:stage "game"})))
#+END_SRC
** game-stage
Here a lot of things are calculated, a whole lot of things.
#+NAME: game-stage
#+BEGIN_SRC clojure
(defn game-stage
  "The function that executes during the game stage."
  [{:as                       state
    enemies                   :enemies
    {player-x       :x
     player-y       :y
     player-speed-x :speed-x
     player-speed-y :speed-y} :player-color
    player-color              :player-color
    time                      :time
    score-color               :score-color
    point-squares             :point-squares
    distance                  :distance}]
  (merge
   state
   (let [new-player-speed-x (+ player-speed-x (io/get-x-accel))
         new-player-speed-y (+ player-speed-y (io/get-y-accel))
         min-x              (- (/ (q/width) 2))
         max-x              (- (/ (q/width) 2) 20)
         min-y              (- (/ (q/height) 2))
         max-y              (- (/ (q/height) 2) 20)
         speed              (q/sqrt (+ (q/pow new-player-speed-x 2) (q/pow new-player-speed-y 2)))]
     (if (engine/player-alive? player-color min-x max-x min-y max-y enemies)
       {:text          (str "SCORE: " (:score-color state) "\n"
                            "FRAME: " (:time state) "\n"
                            "SPEED: " (.toFixed (:speed state) 1))
        :speed         speed
        :distance      (+ distance speed)
        :player-color  (engine/update-player new-player-speed-x new-player-speed-y player-x player-y)
        :enemies       (engine/gen-enemies min-x max-x min-y max-y time speed enemies)
        :point-squares (engine/gen-point-squares player-color min-x max-x min-y max-y point-squares speed time)
        :time          (inc time)
        :score-color   (engine/update-score player-color score-color point-squares)
        :max-score     (:max-score state)}
       {:ignore-keypress true
        :screen-time     0
        :stage           "score-color"}))))
#+END_SRC
** score-stage
#+NAME: score-stage
#+BEGIN_SRC clojure
(defn score-stage
  [state]
  (merge
   state
   (let [restart (if-not (:ignore-keypress state)
                   (q/key-pressed?)
                   false)
         max-score (max (:max-score state) (:score-color state))]
     (if-not restart
       {:text (str "GAME OVER\n"
               "FRAMES:    " (:time state) "\n"
               "DISTANCE:  " (int (:distance state)) "\n"
               "MAX SCORE: " (:max-score state) "\n"
               "SCORE:     " (:score-color state)
               (when (< 60 (:screen-time state))
                     "\n\nPRESS ANY KEY TO CONTINUE..."))
        :screen-time (inc (:screen-time state))
        :ignore-keypress (if (or (q/key-pressed?) (> 30 (:screen-time state)))
                          (:ignore-keypress state)
                          false)
        :speed 0
        :max-score max-score}
       {:player-color {:x -20
                 :y 20}
        :enemies []
        :point-squares []
        :time 0
        :distance 0
        :score-color 0
        :stage "game"}))))
#+END_SRC
** update-stage-state
Here we have a little function that simply switches between the different possible stage states.
#+NAME: update-stage-state
#+BEGIN_SRC clojure
(defn update-stage-state [state]
  (case (:stage state)
        "title" (title-stage state)
        "game" (game-stage state)
        "score-color" (score-stage state)))
#+END_SRC
