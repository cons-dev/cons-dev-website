<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-W51-6 02:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Implementing Binary Tree Sets</title>
<meta name="author" content="Inanna" />
<meta name="description" content="Making sets with binary trees." />
<meta name="generator" content="Org Mode" />
<link href="site.css" rel="stylesheet" type="text/css" /><link href="images/website-icon.png" rel="icon" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div><a href="index.html"><img id="site-logo" src="images/website-logo.png" /></a></div>
</div>
<div id="content" class="content">
<h1 class="title">Implementing Binary Tree Sets</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0feb9f1">Introduction</a></li>
<li><a href="#org454f10c">Implementation</a>
<ul>
<li><a href="#orgfe51b10">Object and Constructor</a></li>
<li><a href="#org6ea2a0d">Insert</a></li>
<li><a href="#org403748f">Contains</a></li>
<li><a href="#org343f351">Traversals</a></li>
<li><a href="#org5201636">Set-theoretic</a></li>
</ul>
</li>
<li><a href="#org8cd3812">Python Code</a></li>
</ul>
</div>
</div>


<div id="outline-container-org0feb9f1" class="outline-2">
<h2 id="org0feb9f1">Introduction</h2>
<div class="outline-text-2" id="text-org0feb9f1">
<p>
Binary trees are a classic datastructure, basically like a linked list but with two children nodes rather than one node. Each of the child nodes can then link to further child nodes and so on until they reach leaf nodes, which are traditionally <code>nil</code>.
</p>


<div id="org3bfd4ca" class="figure">
<p><img src="./images/bintree_17a848ae-1c8a-4a7c-8219-df9f2a794fb3.png" alt="bintree_17a848ae-1c8a-4a7c-8219-df9f2a794fb3.png" />
</p>
</div>

<p>
You can also use them for <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">sets</a> which have a simple, linear space complexity and are fairly space efficient when compared to hash-sets. However, they do have longer access times with \(O(log(n))\) being the standard for most operations.
</p>
</div>
</div>

<div id="outline-container-org454f10c" class="outline-2">
<h2 id="org454f10c">Implementation</h2>
<div class="outline-text-2" id="text-org454f10c">
</div>
<div id="outline-container-orgfe51b10" class="outline-3">
<h3 id="orgfe51b10">Object and Constructor</h3>
<div class="outline-text-3" id="text-orgfe51b10">
<p>
To start it all off we define an object and a constructor. The constructor just takes a seq-able collection and converts it into a binary tree. This only works if elements within the collection can be compared with other elements, otherwise it will return an error.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defrecord</span> <span style="color: #E53935;">BintreeNode</span> <span style="color: #bbb;">[</span>val lesser greater<span style="color: #bbb;">]</span><span style="color: #494949;">)</span>

<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-set</span> <span style="color: #bbb;">[</span>coll<span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span>reduce bintree-insert <span style="color: #E53935;">nil</span> coll<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ea2a0d" class="outline-3">
<h3 id="org6ea2a0d">Insert</h3>
<div class="outline-text-3" id="text-org6ea2a0d">
<p>
Insertion in the binary tree is easy. If a key is present nothing has to be done! It can just return. If the node is nil, then it is at a leaf node and it can insert a new node. Lastly, if it is at a node it checks itself against the value of the node and chooses the lesser (left) side if it is lesser, else the right side and applies itself.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-insert</span> <span style="color: #bbb;">[</span><span style="color: #494949;">{</span><span style="color: #E53935;">:keys</span> <span style="color: #bbb;">[</span>val lesser greater<span style="color: #bbb;">]</span> <span style="color: #E53935;">:as</span> node<span style="color: #494949;">}</span> key<span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">cond</span> <span style="color: #494949;">(</span>= val key<span style="color: #494949;">)</span> node
        <span style="color: #494949;">(</span>nil? node<span style="color: #494949;">)</span> <span style="color: #494949;">(</span>-&gt;BintreeNode key <span style="color: #E53935;">nil</span> <span style="color: #E53935;">nil</span><span style="color: #494949;">)</span>
        <span style="color: #494949;">(</span>&lt; key val<span style="color: #494949;">)</span> <span style="color: #494949;">(</span>assoc node <span style="color: #E53935;">:lesser</span> <span style="color: #bbb;">(</span>bintree-insert lesser key<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
        <span style="color: #E53935;">:else</span>       <span style="color: #494949;">(</span>assoc node <span style="color: #E53935;">:greater</span> <span style="color: #bbb;">(</span>bintree-insert greater key<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org403748f" class="outline-3">
<h3 id="org403748f">Contains</h3>
<div class="outline-text-3" id="text-org403748f">
<p>
Here we define a predicate to check if an element is contained within the binary tree. This function is implemented in almost exactly the same way as the above, traversing until it hits the key itself or nil.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-contains?</span> <span style="color: #bbb;">[</span><span style="color: #494949;">{</span><span style="color: #E53935;">:keys</span> <span style="color: #bbb;">[</span>val lesser greater<span style="color: #bbb;">]</span><span style="color: #494949;">}</span> key<span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">cond</span> <span style="color: #494949;">(</span>= val key<span style="color: #494949;">)</span> <span style="color: #E53935;">true</span>
        <span style="color: #494949;">(</span>nil? val<span style="color: #494949;">)</span>     <span style="color: #E53935;">false</span>
        <span style="color: #494949;">(</span>&lt; key val<span style="color: #494949;">)</span> <span style="color: #494949;">(</span>bintree-contains? lesser key<span style="color: #494949;">)</span>
        <span style="color: #E53935;">:else</span>          <span style="color: #494949;">(</span>bintree-contains? greater key<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org343f351" class="outline-3">
<h3 id="org343f351">Traversals</h3>
<div class="outline-text-3" id="text-org343f351">
<p>
Here we define some traversals for our tree. Traversals are simply functions that recursively visit all the nodes in the tree once.
</p>

<p>
The pre-order traversal returns a list of all nodes with the visited node first, followed by it's lesser and then greater children.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">pre-order</span> <span style="color: #bbb;">[</span><span style="color: #494949;">{</span><span style="color: #E53935;">:keys</span> <span style="color: #bbb;">[</span>val lesser greater<span style="color: #bbb;">]</span><span style="color: #494949;">}</span><span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span>concat <span style="color: #494949;">[</span>val<span style="color: #494949;">]</span>
          <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">when</span> lesser <span style="color: #bbb;">(</span>pre-order lesser<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
          <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">when</span> greater <span style="color: #bbb;">(</span>pre-order greater<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
The post-order traversal does the same, but with the node last.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">post-order</span> <span style="color: #bbb;">[</span><span style="color: #494949;">{</span><span style="color: #E53935;">:keys</span> <span style="color: #bbb;">[</span>val lesser greater<span style="color: #bbb;">]</span><span style="color: #494949;">}</span><span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span>concat <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">when</span> lesser <span style="color: #bbb;">(</span>pre-order lesser<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
          <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">when</span> greater <span style="color: #bbb;">(</span>pre-order greater<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
          <span style="color: #494949;">[</span>val<span style="color: #494949;">]</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Finally, the in-order traversal returns a sorted list of all nodes by visiting the lesser nodes first, itself, and then the greater nodes.
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">in-order</span> <span style="color: #bbb;">[</span><span style="color: #494949;">{</span><span style="color: #E53935;">:keys</span> <span style="color: #bbb;">[</span>val lesser greater<span style="color: #bbb;">]</span><span style="color: #494949;">}</span><span style="color: #bbb;">]</span>
  <span style="color: #bbb;">(</span>concat <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">when</span> lesser <span style="color: #bbb;">(</span>in-order lesser<span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
          <span style="color: #494949;">[</span>val<span style="color: #494949;">]</span>
          <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">when</span> greater <span style="color: #bbb;">(</span>in-order greater<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5201636" class="outline-3">
<h3 id="org5201636">Set-theoretic</h3>
<div class="outline-text-3" id="text-org5201636">
<p>
Here we just implement the various set-theoretic functions.
</p>

<p>
The union function is fairly simple, obtaining the post-order traversal of the first binary tree and then inserting all the elements into the second. It's time complexity is \(O(n\ log(n))\).
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-union</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b &amp; rest<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>reduce bintree-union a <span style="color: #bbb;">(</span>cons b rest<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b<span style="color: #494949;">]</span>
   <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> a post-order <span style="color: #bbb;">(</span>reduce bintree-insert b<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
This just checks if a node is contained in the other tree, and if it is, adds it to the new set of nodes. It's time complexity is \(O(n\ log(n))\).
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-intersection</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b &amp; rest<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>reduce bintree-difference a <span style="color: #bbb;">(</span>cons b rest<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b<span style="color: #494949;">]</span>
   <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> a post-order <span style="color: #bbb;">(</span>filter <span style="color: #494949;">(</span>partial bintree-contains? b<span style="color: #494949;">)</span><span style="color: #bbb;">)</span> bintree-set<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Lastly we find the difference between two binary trees by simply filtering out the set of nodes that are contained within the second binary tree. Like all set-theoretic functions it is variadic and accepts an arbitrary number of arguments. It's time complexity is \(O(n\ log(n))\).
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-difference</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b &amp; rest<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>reduce bintree-difference a <span style="color: #bbb;">(</span>cons b rest<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b<span style="color: #494949;">]</span>
   <span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> a post-order <span style="color: #bbb;">(</span>filter #<span style="color: #494949;">(</span>not <span style="color: #bbb;">(</span>bintree-contains? b <span style="font-style: italic;">%</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span> bintree-set<span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>

<p>
Lastly we have a simple function that determines if one tree is a subset of another tree by checking if each item is contained in the other tree. It's time complexity is (I know you will be shocked) \(O(n\ log(n))\).
</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">defn</span> <span style="font-weight: bold; font-style: italic;">bintree-subset?</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b &amp; rest<span style="color: #494949;">]</span> <span style="color: #494949;">(</span>reduce bintree-difference a <span style="color: #bbb;">(</span>cons b rest<span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span>
  <span style="color: #bbb;">(</span><span style="color: #494949;">[</span>a b<span style="color: #494949;">]</span>
   <span style="color: #494949;">(</span>not <span style="color: #bbb;">(</span><span style="color: #E53935; font-style: italic;">-&gt;&gt;</span> a post-order <span style="color: #494949;">(</span>some #<span style="color: #bbb;">(</span>not <span style="color: #494949;">(</span>bintree-contains? b <span style="font-style: italic;">%</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span><span style="color: #bbb;">)</span><span style="color: #494949;">)</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8cd3812" class="outline-2">
<h2 id="org8cd3812">Python Code</h2>
<div class="outline-text-2" id="text-org8cd3812">
<p>
Below is also the code in python.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #E53935; font-style: italic;">class</span> <span style="color: #E53935;">BintreeNode</span>:
    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">__init__</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>, val<span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">self</span>.gtr = <span style="color: #E53935;">None</span>
        <span style="color: #E53935; font-style: italic;">self</span>.lsr = <span style="color: #E53935;">None</span>
        <span style="color: #E53935; font-style: italic;">self</span>.val = val


<span style="color: #E53935; font-style: italic;">class</span> <span style="color: #E53935;">Bintree</span>:
    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">__init__</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span><span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">self</span>.head = <span style="color: #E53935;">None</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">add_node</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>, val<span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">if</span> <span style="color: #E53935; font-style: italic;">not</span> <span style="color: #E53935; font-style: italic;">self</span>.head:
            <span style="color: #E53935; font-style: italic;">self</span>.head = BintreeNode<span style="color: #494949;">(</span>val<span style="color: #494949;">)</span>
        <span style="color: #E53935; font-style: italic;">else</span>:
            <span style="font-style: italic;">current_node</span> = <span style="color: #E53935; font-style: italic;">self</span>.head
            <span style="font-style: italic;">inserted</span> = <span style="color: #E53935;">False</span>
            <span style="color: #E53935; font-style: italic;">while</span> <span style="color: #E53935; font-style: italic;">not</span> inserted:
                <span style="color: #E53935; font-style: italic;">if</span> current_node.val &gt; val:
                    <span style="color: #E53935; font-style: italic;">if</span> current_node.lsr:
                        <span style="font-style: italic;">current_node</span> = current_node.lsr
                    <span style="color: #E53935; font-style: italic;">else</span>:
                        <span style="font-style: italic;">current_node.lsr</span> = BintreeNode<span style="color: #494949;">(</span>val<span style="color: #494949;">)</span>
                        <span style="font-style: italic;">inserted</span> = <span style="color: #E53935;">True</span>
                <span style="color: #E53935; font-style: italic;">elif</span> current_node.val &lt; val:
                    <span style="color: #E53935; font-style: italic;">if</span> current_node.gtr:
                        <span style="font-style: italic;">current_node</span> = current_node.gtr
                    <span style="color: #E53935; font-style: italic;">else</span>:
                        <span style="font-style: italic;">current_node.gtr</span> = BintreeNode<span style="color: #494949;">(</span>val<span style="color: #494949;">)</span>
                        <span style="font-style: italic;">inserted</span> = <span style="color: #E53935;">True</span>
                <span style="color: #E53935; font-style: italic;">else</span>:
                    <span style="color: #E53935; font-style: italic;">raise</span> <span style="color: #E53935;">Exception</span><span style="color: #494949;">(</span><span style="color: #494949;">"duplicate key"</span><span style="color: #494949;">)</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">node_exists</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>, val<span style="color: #494949;">)</span>:
        <span style="font-style: italic;">exists</span> = <span style="color: #E53935;">False</span>
        <span style="color: #E53935; font-style: italic;">if</span> <span style="color: #E53935; font-style: italic;">self</span>.head:
            <span style="font-style: italic;">current_node</span> = <span style="color: #E53935; font-style: italic;">self</span>.head
            <span style="font-style: italic;">found</span> = <span style="color: #E53935;">False</span>
            <span style="color: #E53935; font-style: italic;">while</span> <span style="color: #E53935; font-style: italic;">not</span> found:
                <span style="color: #E53935; font-style: italic;">if</span> current_node.val &gt; val:
                    <span style="color: #E53935; font-style: italic;">if</span> current_node.lsr:
                        <span style="font-style: italic;">current_node</span> = current_node.lsr
                    <span style="color: #E53935; font-style: italic;">else</span>:
                        <span style="font-style: italic;">exists</span> = <span style="color: #E53935;">False</span>
                        <span style="font-style: italic;">found</span> = <span style="color: #E53935;">True</span>
                <span style="color: #E53935; font-style: italic;">elif</span> current_node.val &lt; val:
                    <span style="color: #E53935; font-style: italic;">if</span> current_node.gtr:
                        <span style="font-style: italic;">current_node</span> = current_node.gtr
                    <span style="color: #E53935; font-style: italic;">else</span>:
                        <span style="font-style: italic;">exists</span> = <span style="color: #E53935;">False</span>
                        <span style="font-style: italic;">found</span> = <span style="color: #E53935;">True</span>
                <span style="color: #E53935; font-style: italic;">else</span>:
                    <span style="font-style: italic;">exists</span> = <span style="color: #E53935;">True</span>
                    <span style="font-style: italic;">found</span> = <span style="color: #E53935;">True</span>
        <span style="color: #E53935; font-style: italic;">return</span> exists
    
    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">inorder</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span><span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">traverse</span><span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>:
            <span style="font-style: italic;">node_list</span> = <span style="color: #494949;">[]</span>
            <span style="color: #E53935; font-style: italic;">if</span> node.lsr:
                <span style="font-style: italic;">node_list</span> += traverse<span style="color: #494949;">(</span>node.lsr<span style="color: #494949;">)</span>
            node_list.append<span style="color: #494949;">(</span>node.val<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">if</span> node.gtr:
                <span style="font-style: italic;">node_list</span> += traverse<span style="color: #494949;">(</span>node.gtr<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">return</span> node_list
        <span style="color: #E53935; font-style: italic;">return</span> traverse<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>.head<span style="color: #494949;">)</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">postorder</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span><span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">traverse</span><span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>:
            <span style="font-style: italic;">node_list</span> = <span style="color: #494949;">[]</span>
            node_list.append<span style="color: #494949;">(</span>node.val<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">if</span> node.lsr:
                <span style="font-style: italic;">node_list</span> += traverse<span style="color: #494949;">(</span>node.lsr<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">if</span> node.gtr:
                <span style="font-style: italic;">node_list</span> += traverse<span style="color: #494949;">(</span>node.gtr<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">return</span> node_list
        <span style="color: #E53935; font-style: italic;">return</span> traverse<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>.head<span style="color: #494949;">)</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">preorder</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span><span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">traverse</span><span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>:
            <span style="font-style: italic;">node_list</span> = <span style="color: #494949;">[]</span>
            <span style="color: #E53935; font-style: italic;">if</span> node.lsr:
                <span style="font-style: italic;">node_list</span> += traverse<span style="color: #494949;">(</span>node.lsr<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">if</span> node.gtr:
                <span style="font-style: italic;">node_list</span> += traverse<span style="color: #494949;">(</span>node.gtr<span style="color: #494949;">)</span>
            node_list.append<span style="color: #494949;">(</span>node.val<span style="color: #494949;">)</span>
            <span style="color: #E53935; font-style: italic;">return</span> node_list
        <span style="color: #E53935; font-style: italic;">return</span> traverse<span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>.head<span style="color: #494949;">)</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">union</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>, other<span style="color: #494949;">)</span>:
        <span style="color: #E53935; font-style: italic;">for</span> node <span style="color: #E53935; font-style: italic;">in</span> other.preorder<span style="color: #494949;">()</span>:
            <span style="color: #E53935; font-style: italic;">self</span>.add_node<span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">intersection</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>, other<span style="color: #494949;">)</span>:
        <span style="font-style: italic;">isect_set</span> = Bintree<span style="color: #494949;">()</span>
        <span style="color: #E53935; font-style: italic;">for</span> node <span style="color: #E53935; font-style: italic;">in</span> other.preorder<span style="color: #494949;">()</span>:
            <span style="color: #E53935; font-style: italic;">if</span> <span style="color: #E53935; font-style: italic;">self</span>.node_exists<span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>:
                isect_set.add_node<span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>

    <span style="color: #E53935; font-style: italic;">def</span> <span style="font-weight: bold; font-style: italic;">difference</span><span style="color: #494949;">(</span><span style="color: #E53935; font-style: italic;">self</span>, other<span style="color: #494949;">)</span>:
        <span style="font-style: italic;">diff_set</span> = Bintree<span style="color: #494949;">()</span>
        <span style="color: #E53935; font-style: italic;">for</span> node <span style="color: #E53935; font-style: italic;">in</span> <span style="color: #E53935; font-style: italic;">self</span>.preorder<span style="color: #494949;">()</span>:
            <span style="color: #E53935; font-style: italic;">if</span> <span style="color: #E53935; font-style: italic;">not</span> other.node_exists<span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>:
                diff_set.add_node<span style="color: #494949;">(</span>node<span style="color: #494949;">)</span>

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Last Modified: 2021-W51-6 02:14</p><p class="creator">Generated Using: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.6)</p><p class="license">Except where otherwise noted content on <a href="https://cons.dev">cons.dev</a> is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
</div>
</body>
</html>
